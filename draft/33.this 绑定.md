# 正则表达式
## <a name="index"></a> 目录
- [引子](#start)
- [问题1](#style)
  - [问题12](#link)
- [参考资料](#reference)


## <a name="start"></a> 引子
在[关于 this 的误解][url-segment38]中对 `this` 有了基本了解，每个函数的 `this` 是在调用时绑定的，接着继续看下调用位置是如何决定 `this` 的绑定对象。

## 绑定规则
### 默认绑定
思考下面代码：
```javascript
  function book() {
    console.info(this.color);
  }

  var color = 'red';

  book(); // 'red'
```
这是很常见的独立函数调用。`book()` 直接在全局环境下进行调用，应用了 `this` 的默认绑定，此时 `this` 指向全局对象。所以可以获取到全局变量 `color` 。

如果使用严格模式，无法使用默认绑定，`this` 会绑定到 `undefined` ：
```javascript
  function book() {
    "use strict";
    console.info(this.color);
  }

  var color = 'red';

  book(); // Uncaught TypeError: Cannot read property 'color' of undefined
```
`book()` 运行在非严格模式下时，默认绑定才能绑定到全局对象，严格模式下与 `book()` 的调用位置无关。
```javascript
  function book() {
    console.info(this.color);
  }

  var color = 'red';

  (function() {
    "use strict";
    book(); // 'red'
  })();
```
### 隐式绑定
思考下面代码：
```javascript
  function getColor() {
    console.info(this.color);
  }

  var obj = {
    color:'green',
    getColor:getColor
  };

  obj.getColor(); // 'green'
```
当 `getColor()` 调用时，使用了 `obj` 上下文对象，这个时候 `this` 会绑定到 `obj` 上，所以 `this.color` 和 `obj.color` 是一样的。

在对象属性引用链中只有最后一层会影响调用位置。例如：
```javascript
  function getColor() {
    console.info(this.color);
  }

  var obj2 = {
    color: 'blue',
    getColor: getColor
  };

  var obj1 = {
    color: 'green',
    obj2: obj2
  };

  obj1.obj2.getColor(); // 'blue'
```
#### 绑定丢失
有个常见的情况是 `this` 绑定会丢失绑定对象，应用默认绑定，也就是说把 `this` 绑定到全局全局对象或 `undefined` 上。例如下面的例子：
```javascript
  function getColor() {
    console.info(this.color);
  }

  var obj = {
    color:'green',
    getColor:getColor
  };

  var color = 'red';

  var getFunction = obj.getColor; // 函数别名

  getFunction(); // 'red'
```
`getFunction` 最终引用的还是是 `getColor` 函数本身，`getFunction()` 其实就是一个函数调用，这种情况下只能应用默认绑定。

函数传参也会出现这样的情况，如下：
```javascript
  function getColor() {
    console.info(this.color);
  }

  var obj = {
    color:'green',
    getColor:getColor
  };

  var color = 'red';

  setTimeout(obj.getColor,222); // 'red'
```

### 显式绑定
显式绑定是指直接指定 `this` 的绑定对象，使用的是函数的 `call`、`apply`、`bind` 方法。
```javascript
  function getColor() {
    console.info(this.color);
  }

  var obj = {
    color:'green'
  };

  getColor.call(obj); // 'green'
```
显示绑定的一个变种可以解决前面提到的丢失绑定的问题。
```javascript
  function getColor() {
    console.info(this.color);
  }

  var obj = {
    color:'green'
  };

  var getFunction = function() {
    getColor.call(obj);
  };

  getFunction(); // 'green'
```
`getFunction()` 函数内部手动调用了 `getColor.call(obj)`，把 `getColor` 的 `this` 绑定到 `obj` ，之后无论怎么调用都会绑定到对象 `obj` 上。这是一种显式的强制绑定。

### new 绑定
`new` 是可影响函数调用时 `this` 绑定行为的方法。使用 `new` 来调用函数时，会自动执行下面的操作：
1. 创建一个新的对象。
2. 这个新对象会执行 [[prototype]] 连接。
3. 这个新对象会绑定到函数调用的 `this`。
4. 如果函数没有返回其它对象，那么会自动返回这个新对象。

示例如下：
```javascript
  function getColor(color) {
    this.color = color;
  }

  var obj = new getColor('red');
  console.info(obj.color); // 'red'
```
关于 `new` 操作符，可以看一下这里 [The new Operator][url-segment37]。

## 优先级

## 绑定例外

## 小结

## <a name="reference"></a> 参考资料
- [this][url-mdn-this]
- [How does the “this” keyword work?][url-stackoverflow-question]
- [You-Dont-Know-JS][url-github-book]
- [JavaScript 的 this 原理][url-blog1]

[url-base]:https://xxholic.github.io/blog/draft

[url-mdn-this]:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this
[url-stackoverflow-question]:https://stackoverflow.com/questions/3127429/how-does-the-this-keyword-work
[url-github-book]:https://github.com/getify/You-Dont-Know-JS
[url-blog1]:http://www.ruanyifeng.com/blog/2018/06/javascript-this.html

[url-segment38]:https://github.com/XXHolic/segment/issues/40
[url-segment37]:https://github.com/XXHolic/segment/issues/39
