# 76.Scalable Frontend 2 — Common Patterns.79
## <a name="index"></a> 目录
- [引子](#start)
- [正文](#main)
  - [title11](#title11)
- [参考资料](#reference)


## <a name="start"></a> 引子
继 [Scalable Frontend 1  — Architecture Fundamentals][url-2] 第二篇。

原文：[Scalable Frontend #2 — Common Patterns][url-1]

## <a name="main"></a> 正文
![76-head][url-local-1]

模式应该很好的适应，就像玩积木。

让我们继续前端可扩展性的讨论！在上一篇文章中，我们讨论了前端应用程序的架构基础，但仅限于概念。现在我们要用实际的代码亲自实践一下。

## <a name="patterns"></a> 常见模式（Common patterns）
我们如何实现第一篇文章中提到的架构？和我们以前做的相比有什么不同？我们如何将所有这些与依赖注入结合起来？

无论你使用哪个库来抽象视图或管理状态，在前端应用程序中有一些反复出现的模式。现在我们将要谈谈其中的一些，所以系好安全带，准备开车了！

## <a name="use-case"></a> 用例（Use cases）
我们选择用*例作* 为第一种模式，因为在架构方面，它们是我们与软件交互的方式。用例在一个高层次上讲述我们的应用程序做了什么；它们是我们特性的配方；是应用层的主要单元。它们定义应用程序本身。

用力通常也称为 *互动者* ，它负责执行与其它层之间的交互。他们：
- 被输入层调用，
- 应用它们的算法，
- 使定义域层和基础设施层交互试，不必关心它们内部的工作方式，并且，
- 将结果状态返回给输入层。结果状态表明用例是成功还是失败，原因是内部错误、验证失败、前置条件等。

了解结果状态是很有用的，因为它有助于确定要为结果响应什么操作，从而允许 UI 中有更丰富的信息，这样用户就可以知道在失败情况下发生了什么错误。但这里有一个重要细节：结果状态的逻辑应该在用例内部，而不是输入层——因为这一点不是输入层的责任。这意味着输入层*不* 应该接收从用例传递来的通用错误对象，并求助于使用 `if` 语句来找出失败的原因，比如检查 ``error.message` 属性或使用 `instanceof` 查询错误的类。

这让我们碰到一个棘手的事实：从用例中返回 promise 可能不是最佳的设计决策，因为 promise 只有两种可能的结果：成功和失败，需要我们借助 `catch()` 语句找到失败的原因。这是否意味着在软件中我们应该忽略 promise ？不！只要输入层对此一无所知，就完全可以从我们代码的其它部分返回 promise ，比如操作、存储库和服务。克服这个限制的一个简单方法是，对用例的每个可能结果状态提供一个回调。

用例的另一个重要特征是，它们应该遵循层与层之间的边界：不知道什么入口点在调用它们，即使在只有一个入口点的前端也是如此。这意味着我们不应该在用例中接触浏览器全局变量、DOM 特定值、或任何其它低级别对象。例如：我们不应该接收 `<input/>` 元素的实例作为参数，然后读取它的值；输入层应该负责提取这个值并将它传递给用例。

没有什么能比举例说明更清楚：
```js
export default ({ validateUser, userRepository }) => async (userData, { onSuccess, onError, onValidationError }) => {
  if(!validateUser(userData)) {
    return onValidationError(new Error('Invalid user'));
  }

  try {
    const user = await userRepository.add(userData);
    onSuccess(user);

  } catch(error) {
    onError(error);
  }
};
```
```js
const createUserAction = (userData) => (dispatch, getState, container) => {
  container.createUser(userData, {
    // notice that we don't add conditionals to emit any of these actions
    onSuccess: (user) => dispatch(createUserSuccessAction(user)),
    onError: (error) => dispatch(createUserErrorAction(error)),
    onValidationError: (error) => dispatch(createUserValidationErrorAction(error))
  });
};
```
注意，在 `userAction` 中，我们不会对 `createUser` 用例的响应做出任何断言；我们相信用例会为每个结果调用正确的回调。而且，即使 `userData` 对象中的值来自 HTML 输入，用例对此一无所知。它只接收提取的数据并将其转发。

就是这样了！用例不应该做更多的事了。你能看出现在测试它们有多容易吗？我们只要注入我们想要的模拟依赖项，并测试用例是否针对每种情况调用了正确的回调。

## <a name="entities-value-aggregates"></a> 实体、值对象和聚合（Entities, value objects, and aggregates）


<div align="right"><a href="#index">Back to top :arrow_up:</a></div>

## <a name="reference"></a> 参考资料
- [Scalable Frontend #2 — Common Patterns][url-1]

[url-1]:https://blog.codeminer42.com/scalable-frontend-2-common-patterns-d2f28aef0714/
[url-2]:https://github.com/XXHolic/blog/issues/78

[url-local-1]:./images/76/head.jpeg

<details>
<summary>:wastebasket:</summary>

![n-poster][url-local-poster]

</details>

[url-book]:https://book.douban.com/subject/26916012/
[url-local-poster]:./images/n/poster.jpg
