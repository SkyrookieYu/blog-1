# 75.Scalable Frontend 1  — Architecture Fundamentals.78
## <a name="index"></a> 目录
- [引子](#start)
- [正文](#main)
  - [title11](#title11)
- [参考资料](#reference)


## <a name="start"></a> 引子
读了关于可扩展前端讨论的一些文章，翻译记录。

原文：[Scalable Frontend #1 — Architecture Fundamentals][url-1]

## <a name="main"></a> 正文
关于软件开发中“可扩展性”一词最常见的两个含义，与随着时间推移代码库的性能和可维护性有关。你可以同时拥有它们，但是注重良好的可维护性，可以让优化性能变的更容易，且不会影响应用程序其余部分。更重要的是在前端，与后端有一个重要的区别：本地状态。

在这个系列文章中，我们将讨论如何使用经过实际测试的方法，开发和维护一个可扩展的前端应用程序。我们大多数示例将使用 React 和 Redux ，但我们将经常与其他技术栈进行比较，展示如何达到相同的效果。让我们以讨论架构开始这个系列，这是你软件中最重要的部分。

## <a name="architecture"></a> 软件架构是什么？
软件架构到底是什么？说它是软件中最重要的部分似乎有些虚夸，请容我继续说下去。

架构是你如何让软件的各个单元彼此合作，以强调必须要做出的最重要决策，并推迟次要决策和实现细节。设计软架构意味着将实际应用程序与其支持的技术脱离开来。你的实际应用程序不了解数据库、AJAX 请求或 GUI ；代替的是，由代表了你的软件所涵盖概念的用例和定义域单元组成，不考虑执行用例的参与者或数据持久化的位置。

关于架构，还有一些重要的事情要说：它不意味着文件组织，也不意味着你是如何命名文件和文件夹。

## <a name="layers"></a> 前端开发中的层次
区分什么是重要什么是次要的一种方式是使用分层，每一层都有不同具体的职责。基于分层的架构中，一种常见的方式是将其分为四层：应用层（application）、定义域层（domain）、基础设施层（infrastructure）和输入层（input）。这四层在文章 [NodeJS and Good Practices][url-2] 中有更好的解释。我们建议你在继续之前阅读该文章的第一部分。你不必阅读第二部分，因为它是关于 NodeJS 的。

定义域和应用层在前端和后端之间没有什么不同，因为它们与技术无关，但我们对于输入层和基础设施层不能这么说。在 web 浏览器中，通常在输入层（视图）有一个参与者，因此我们甚至可以将其称为*视图层* 。另外，前端没有访问数据库或队列引擎的权限，因此我们在前端基础设施层中找不到这些。而我们将发现的是封装 AJAX 请求、浏览器 cookie 、LocalStorage 甚至与 WebSocket 服务器交互单元的抽象。主要的区别只是抽象的内容，所以你甚至可以拥有接口完全相同但底层技术不同的前端和后端[存储库][url-3]。你能想象一个好的抽象是多么的棒吗？

无论你是使用 React、Vue、Angular 还是其它工具来创建你的视图都没有关系。重要的是要遵循输入层没有任何逻辑的规则，这样将输入参数传递给下一层。对于基于分层架构的前端，还有另一个重要规则：要让输入/视图层始终与本地状态保持同步，你应该遵循单向数据流。这个词听上去熟悉吗？我们可以通过增加特定的第五层来实现这一点：状态，也称为存储。

## <a name="state"></a> 状态层
当遵循单向数据流时，我们从不更改或转换从视图中直接接收的数据。代替的是，我们会从视图中分发“ actions ”。它是这样运行的：一个 action 向数据源发送一条消息，数据源更新自己，然后用新数据重新渲染视图。请注意，绝不会有从视图到存储的直接通道，因此如果两个子视图使用相同的数据，那么你就可以从其中任何一个子视图分发 action ，这都将导致它们用新数据重新渲染。看起来我是在专门讨论 React 和 Redux ，但并不是这样的；你可以用几乎所有现代前端框架或库，实现相同的效果，比如 React + context API、Vue + Vuex、Angular + NGXS ，甚至 Ember using the data-down action-up approach (a.k.a. DDAU)。你甚至可以使用 jQuery 的事件系统发送 actions ！

这一层负责管理前端本地和不断变化的状态，如从后端获取的数据、在前端创建但未持久化的临时数据，或请求状态等临时信息。如果你还在琢磨，这就是 actions 和它们对应负责更新状态的处理程序所在的层。

尽管在操作中直接看到带有业务规则和用例定义的代码库是很常见，但是如果你仔细阅读其它层的描述，会发现我们已经有了放置用例和业务规则的地方，而且并不是状态层。这是否意味着我们的 actions 现在成了用例？不！那么我们应该如何对待它们？


<div align="right"><a href="#index">Back to top :arrow_up:</a></div>

## <a name="reference"></a> 参考资料
- [Scalable Frontend #1 — Architecture Fundamentals][url-article-1]

[url-1]:https://blog.codeminer42.com/scalable-frontend-1-architecture-9b80a16b8ec7/
[url-2]:https://github.com/XXHolic/blog/issues/77
[url-3]:https://martinfowler.com/eaaCatalog/repository.html

[url-local-1]:./images/75/head.jpeg

<details>
<summary>:wastebasket:</summary>

![n-poster][url-local-poster]

</details>

[url-book]:https://book.douban.com/subject/26916012/
[url-local-poster]:./images/n/poster.jpg
