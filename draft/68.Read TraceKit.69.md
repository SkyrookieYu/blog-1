# 68.Read TraceKit.69
## <a name="index"></a> 目录
- [引子](#start)
- [title1](#title1)
  - [title11](#title11)
- [参考资料](#reference)


## <a name="start"></a> 引子
前端异常研究，发现了这个库，sentry 里面也基于这个库再改造了，就去看了下源码。

## <a name="intro"></a> 简介
TraceKit 对浏览器堆栈进行解析追踪，对市场上主要的浏览器都做了测试。在浏览器异常一些方面做了比较详尽的处理。

## <a name="thought"></a> 思路
源码中的一些思路：
1. 通过订阅的方式向外部抛出处理后的异常。
2. 主要对 onerror 和 onunhandledrejection 事件进行了包装，支持撤销包装。
3. 多个异常产生时，优先处理最近的异常。

下面针对主要的逻辑进行介绍。

## 具体实现
捕获异常并解析主要有三种途径： onerror、onunhandledrejection、TraceKit.report 。

### onerror

<details>
<summary>源码</summary>

```js
/**
 * Ensures all global unhandled exceptions are recorded.
 * Supported by Gecko and IE.
 * @param {string} message Error message.
 * @param {string} url URL of script that generated the exception.
 * @param {(number|string)} lineNo The line number at which the error occurred.
 * @param {(number|string)=} columnNo The column number at which the error occurred.
 * @param {Error=} errorObj The actual Error object.
 * @memberof TraceKit.report
 */
function traceKitWindowOnError(message, url, lineNo, columnNo, errorObj) {
    var stack = null;

    if (lastExceptionStack) {
        TraceKit.computeStackTrace.augmentStackTraceWithInitialElement(lastExceptionStack, url, lineNo, message);
      processLastException();
    } else if (errorObj) {
        stack = TraceKit.computeStackTrace(errorObj);
        notifyHandlers(stack, true, errorObj);
    } else {
        var location = {
          'url': url,
          'line': lineNo,
          'column': columnNo
        };

        var name;
        var msg = message; // must be new var or will modify original `arguments`
        if ({}.toString.call(message) === '[object String]') {
            var groups = message.match(ERROR_TYPES_RE);
            if (groups) {
                name = groups[1];
                msg = groups[2];
            }
        }

        location.func = TraceKit.computeStackTrace.guessFunctionName(location.url, location.line);
        location.context = TraceKit.computeStackTrace.gatherContext(location.url, location.line);
        stack = {
            'name': name,
            'message': msg,
            'mode': 'onerror',
            'stack': [location]
        };

        notifyHandlers(stack, true, null);
    }

    if (_oldOnerrorHandler) {
        return _oldOnerrorHandler.apply(this, arguments);
    }

    return false;
}
```

</details>

再封装后的 onerror 中将异常分为了三类：
1. 优先处理 lastExceptionStack 记录的值；
2. 不符合条件 1 就处理 errorObj 有值的情况；
3. 不符合 1 和 2 ，构造一个异常返回。

比较多的异常会在第二类中进行处理，执行 TraceKit.computeStackTrace 方法。

TraceKit.computeStackTrace 方法中对异常分为 4 种类型进行处理：
1. computeStackTraceFromStacktraceProp(ex) 针对 Opera 10+ 中抛出的异常进行处理；
2. computeStackTraceFromStackProp(ex) 针对 Chrome、 Gecko 中抛出的异常进行处理；
3. computeStackTraceFromOperaMultiLineMessage(ex) 针对 Opera 9 及其更早版本抛出的异常进行处理；
4. computeStackTraceByWalkingCallerChain(ex) 针对 Safari、 IE 中抛出的异常进行处理；

先看看使用比较多的 Chrome 中的处理 computeStackTraceFromStackProp(ex) 方法。

<details>
<summary>源码</summary>

```js
    /**
     * Computes stack trace information from the stack property.
     * Chrome and Gecko use this property.
     * @param {Error} ex
     * @return {?TraceKit.StackTrace} Stack trace information.
     * @memberof TraceKit.computeStackTrace
     */
    function computeStackTraceFromStackProp(ex) {
        if (!ex.stack) {
            return null;
        }

        var chrome = /^\s*at (.*?) ?\(((?:file|https?|blob|chrome-extension|native|eval|webpack|<anonymous>|\/).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i,
            gecko = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|\[native).*?|[^@]*bundle)(?::(\d+))?(?::(\d+))?\s*$/i,
            winjs = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i,

            // Used to additionally parse URL/line/column from eval frames
            isEval,
            geckoEval = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i,
            chromeEval = /\((\S*)(?::(\d+))(?::(\d+))\)/,

            lines = ex.stack.split('\n'),
            stack = [],
            submatch,
            parts,
            element,
            reference = /^(.*) is undefined$/.exec(ex.message);

        for (var i = 0, j = lines.length; i < j; ++i) {
            if ((parts = chrome.exec(lines[i]))) {
                var isNative = parts[2] && parts[2].indexOf('native') === 0; // start of line
                isEval = parts[2] && parts[2].indexOf('eval') === 0; // start of line
                if (isEval && (submatch = chromeEval.exec(parts[2]))) {
                    // throw out eval line/column and use top-most line/column number
                    parts[2] = submatch[1]; // url
                    parts[3] = submatch[2]; // line
                    parts[4] = submatch[3]; // column
                }
                element = {
                    'url': !isNative ? parts[2] : null,
                    'func': parts[1] || UNKNOWN_FUNCTION,
                    'args': isNative ? [parts[2]] : [],
                    'line': parts[3] ? +parts[3] : null,
                    'column': parts[4] ? +parts[4] : null
                };
            } else if ( parts = winjs.exec(lines[i]) ) {
                element = {
                    'url': parts[2],
                    'func': parts[1] || UNKNOWN_FUNCTION,
                    'args': [],
                    'line': +parts[3],
                    'column': parts[4] ? +parts[4] : null
                };
            } else if ((parts = gecko.exec(lines[i]))) {
                isEval = parts[3] && parts[3].indexOf(' > eval') > -1;
                if (isEval && (submatch = geckoEval.exec(parts[3]))) {
                    // throw out eval line/column and use top-most line number
                    parts[3] = submatch[1];
                    parts[4] = submatch[2];
                    parts[5] = null; // no column when eval
                } else if (i === 0 && !parts[5] && !_isUndefined(ex.columnNumber)) {
                    // FireFox uses this awesome columnNumber property for its top frame
                    // Also note, Firefox's column number is 0-based and everything else expects 1-based,
                    // so adding 1
                    // NOTE: this hack doesn't work if top-most frame is eval
                    stack[0].column = ex.columnNumber + 1;
                }
                element = {
                    'url': parts[3],
                    'func': parts[1] || UNKNOWN_FUNCTION,
                    'args': parts[2] ? parts[2].split(',') : [],
                    'line': parts[4] ? +parts[4] : null,
                    'column': parts[5] ? +parts[5] : null
                };
            } else {
                continue;
            }

            if (!element.func && element.line) {
                element.func = guessFunctionName(element.url, element.line);
            }

            element.context = element.line ? gatherContext(element.url, element.line) : null;
            stack.push(element);
        }

        if (!stack.length) {
            return null;
        }

        if (stack[0] && stack[0].line && !stack[0].column && reference) {
            stack[0].column = findSourceInLine(reference[1], stack[0].url, stack[0].line);
        }

        return {
            'mode': 'stack',
            'name': ex.name,
            'message': ex.message,
            'stack': stack
        };
    }
```

</details>




<div align="right"><a href="#index">Back to top :arrow_up:</a></div>

## <a name="reference"></a> 参考资料
- [TraceKit][url-github-1]

[url-github-1]:https://github.com/csnover/TraceKit

[url-local-rail]:./images/n/rail.png

<details>
<summary>:wastebasket:</summary>

![n-poster][url-local-poster]

</details>

[url-book]:https://book.douban.com/subject/26916012/
[url-local-poster]:./images/n/poster.jpg
