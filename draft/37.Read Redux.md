# 37.Read Redux
## <a name="index"></a> 目录
- [引子](#start)
- [基本概念](#concept)
- [主要思路实现](#achieve)
- [其它 API 实现](#other)
- [思考](#think)
- [参考资料](#reference)


## <a name="start"></a> 引子
之前看过一些对于 redux 源码的解读，现在想按照自己的想法写一写。

从 2018.04.18 Redux v4.0.0 之后就没有发过大的版本了，现在处于一个很稳定的阶段。

下面是查看代码所处分支、时间、commit 的信息：
- 代码分支——master
- commit 时间——2019.06.17
- commit content——removed distinctState() filter (#3450)
- commit hash——beb1fc29ca6ebe45226caa3a064476072cd9ed26


## <a name="concept"></a> 基本概念
Redux 是 JavaScript 状态容器，提供可预测化的状态管理。可以和很多框架配合使用。

Redux 三大原则：
- 单一数据源（Single source of truth）：整个应用的 `state` 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 `store` 中。
- State 是只读的（State is read-only）：唯一改变 state 的方法就是触发 `action`，`action` 是一个用于描述已发生事件的普通对象。
- 使用纯函数来执行修改（Changes are made with pure functions）：为了描述 action 如何改变 state tree ，你需要编写 `reducers`。

`Action` 描述有事情发生，把数据从应用传到 `store` 的有效载荷。它是 `store` 数据的唯一来源。
`Action 创建函数` 就是生成 `action` 的方法。

`Reducers` 指定了应用状态的变化如何响应 `actions` 并发送到 `store` 。

`action` 来描述“发生了什么”，使用 `reducers` 来根据 `action` 更新 `state`，`Store` 就是把它们联系到一起的对象。

详细介绍见[官方文档][url-docs-redux]。

下面结合官方文档中的例子去看源码。

<div align="right"><a href="#index">Back to top :arrow_up:</a></div>

## <a name="achieve"></a> 主要实现
在文档 `基础（Basic Tutorial）` 一章中，先提供了一个纯 JavaScript 的例子，这里取其中一部分完整的逻辑如下。
```javascript
/*
 * actions.js 文件
 */
// action 类型
export const ADD_TODO = "ADD_TODO";
// action 创建函数
export function addTodo(text) {
  return { type: ADD_TODO, text };
}

/*
 * reducers.js 文件
 */
const initialState = {
  todos: []
};

function todosFun(state = [], action) {
  switch (action.type) {
    case "ADD_TODO":
      return [...state, { text: action.text, completed: false }];
    default:
      return state;
  }
}

function todoApp(state = initialState, action) {
  return {
    todos:todosFun(state.todos, action)
  };
}

export default todoApp;

/*
 * index.js 文件
 */
import { createStore } from 'redux';
import { addTodo } from "./actions";
import todoApp from './reducers';

let store = createStore(todoApp);

// 每次 state 更新时，打印日志
const unsubscribe = store.subscribe(() =>
  console.log(store.getState())
);

// 发起 action
store.dispatch(addTodo('Learn about redux'))

// 停止监听 state 更新
unsubscribe();
```
从例子里面可以发现，action 和 reduce 都是很常见的函数和对象，在 index.js 文件里面才出现了跟 redux 相关的调用，首先看下 `createStore(todoApp)` 做了什么。

API 文档中说是创建一个 Redux store 来以存放应用中所有的 state，有三个参数依次是：
1. reducer：是一个方法，这个方法接收两个参数，分别是当前的 state 树和要处理的 action，返回新的 state 树。
2. preloadedState：初始 state。
3. enhancer：是一个组合 store creator 的高阶函数，返回一个新的强化过的 store creator。

在 `createStore(todoApp)` 中用到了第一个参数，传参也符合文档描述要求。看了源码后，发现除了文档说的作用，还有其它的作用。

先列出 createStore 方法中主要组成
```javascript
function createStore(reducer, preloadedState, enhancer) {
  // 主要变量
  var currentReducer = reducer
  var currentState = preloadedState
  var currentListeners = []
  var nextListeners = currentListeners
  var isDispatching = false

  // 方法
  function ensureCanMutateNextListeners() {} // 对 currentListeners 浅复制
  function getState() {} // 获取当前 state
  function subscribe(listener) {} // 添加监听
  function dispatch(action) {} // 分发 action ，这是唯一能够让 state 改变的方式。
  function replaceReducer(nextReducer) {} // 替换当前 reducer
  function observable() {} // 可观察/反应库的互操作点

  // 主要执行逻辑
  dispatch({
    type: ActionTypes.INIT
  })

  return {
    dispatch,
    subscribe,
    getState,
    replaceReducer,
    [$$observable]: observable
  }
}
```
其中 ActionTypes.INIT 并不是 createStore 的内部变量，找到后是这样的：
```javascript
/**
 * 这些是 Redux 内部保留的私有 action 类型
 */
const randomString = () =>
  Math.random()
    .toString(36)
    .substring(7)
    .split('')
    .join('.')

const ActionTypes = {
  INIT: `@@redux/INIT${randomString()}`,
  REPLACE: `@@redux/REPLACE${randomString()}`,
  PROBE_UNKNOWN_ACTION: () => `@@redux/PROBE_UNKNOWN_ACTION${randomString()}`
}

export default ActionTypes
```
差不多齐了，可以发现在 createStore 执行后除了对外提供一些常见的接口，主要就执行了一次 dispatch 触发了一次 state 初始化操作，那么接着就是看下 dispatch 方法里面做了什么。除去检查和容错处理，主要的逻辑如下：
```javascript
  function dispatch(action) {
    try {
      isDispatching = true
      currentState = currentReducer(currentState, action)
    } finally {
      isDispatching = false
    }

    const listeners = (currentListeners = nextListeners)
    for (let i = 0; i < listeners.length; i++) {
      const listener = listeners[i]
      listener()
    }

    return action
  }
```
处理的逻辑：
1. 将分发的状态置为 true ，表示正在分发 action。
2. 设置当前 state，其中 `currentReducer` 就是一开始传给 `createStore` 的参数 todoApp，也就是 reducer.js 文件里面导出的方法 todoApp，这时传入的 ActionTypes.INIT 在程序中没有匹配，返回了默认的 initialState。
3. state 产生变化，执行相关监听程序。

初始化的过程就这样结束了。这个函数里面就是 redux 的主要实现逻辑，简单来说就是将我们自己编写的 action 和 reducer，通过 dispatch 方法一一对应起来，每次想要改变 state，必须要通过 dispatch 方法。例如 index.js 文件里面后面执行的语句：
```javascript
store.dispatch(addTodo('Learn about redux'))
```
`addTodo` 是 action 创建函数，返回的结果是 `{ type: 'ADD_TODO', 'Learn about redux' }`，通过 dispatch 方法，将这个结果传递了 reducer.js 里面的 todoApp 方法接收，进行相应的处理后，返回了新的 state 值 `{todos:[{text: 'Learn about redux', completed: false}]}`。

更加详细的代码和注释见源文件 [createStore.js][url-file-create-store]。

<div align="right"><a href="#index">Back to top :arrow_up:</a></div>

## <a name="other"></a> 其它 API 实现
下面针对几个其它 API 的实现介绍一下。
```javascript

```


<div align="right"><a href="#index">Back to top :arrow_up:</a></div>

## <a name="think"></a> 思考
`Generator` 函数。
```javascript

```


<div align="right"><a href="#index">Back to top :arrow_up:</a></div>


## <a name="reference"></a> 参考资料
- [Redux Github][url-github-redux]
- [Redux][url-docs-redux]

[url-base]:https://xxholic.github.io/blog/draft

[url-github-redux]:https://github.com/reduxjs/redux
[url-docs-redux]:https://redux.js.org/

[url-file-create-store]:https://github.com/reduxjs/redux/blob/master/src/createStore.js




