# 37.Read Redux
## <a name="index"></a> 目录
- [引子](#start)
- [基本概念](#concept)
- [主要思路实现](#achieve)
- [其它 API 实现](#other)
- [思考](#think)
- [参考资料](#reference)


## <a name="start"></a> 引子
之前看过一些对于 redux 源码的解读，现在想按照自己的想法写一写。

从 2018.04.18 Redux v4.0.0 之后就没有发过大的版本了，现在处于一个很稳定的阶段。

下面是查看代码所处分支、时间、commit 的信息：
- 代码分支——master
- commit 时间——2019.06.17
- commit content——removed distinctState() filter (#3450)
- commit hash——beb1fc29ca6ebe45226caa3a064476072cd9ed26


## <a name="concept"></a> 基本概念
Redux 是 JavaScript 状态容器，提供可预测化的状态管理。可以和很多框架配合使用。

Redux 三大原则：
- 单一数据源（Single source of truth）：整个应用的 `state` 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 `store` 中。
- State 是只读的（State is read-only）：唯一改变 state 的方法就是触发 `action`，`action` 是一个用于描述已发生事件的普通对象。
- 使用纯函数来执行修改（Changes are made with pure functions）：为了描述 action 如何改变 state tree ，你需要编写 `reducers`。

`Action` 描述有事情发生，把数据从应用传到 `store` 的有效载荷。它是 `store` 数据的唯一来源。
`Action 创建函数` 就是生成 `action` 的方法。

`Reducers` 指定了应用状态的变化如何响应 `actions` 并发送到 `store` 。

`action` 来描述“发生了什么”，使用 `reducers` 来根据 `action` 更新 `state`，`Store` 就是把它们联系到一起的对象。

详细介绍见[官方文档][url-docs-redux]。

下面结合官方文档中的例子去看源码。

<div align="right"><a href="#index">Back to top :arrow_up:</a></div>

## <a name="achieve"></a> 主要实现
在文档 `基础（Basic Tutorial）` 一章中，先提供了一个纯 JavaScript 的例子，这里取其中一部分完整的逻辑如下。
```javascript
/*
 * actions.js 文件
 */
// action 类型
export const ADD_TODO = "ADD_TODO";
// action 创建函数
export function addTodo(text) {
  return { type: ADD_TODO, text };
}

/*
 * reducers.js 文件
 */
const initialState = {
  todos: []
};

function todosFun(state = [], action) {
  switch (action.type) {
    case "ADD_TODO":
      return [...state, { text: action.text, completed: false }];
    default:
      return state;
  }
}

function todoApp(state = initialState, action) {
  return {
    todos:todosFun(state.todos, action)
  };
}

export default todoApp;

/*
 * index.js 文件
 */
import { createStore } from 'redux';
import { addTodo } from "./actions";
import todoApp from './reducers';

let store = createStore(todoApp);

// 每次 state 更新时，打印日志
const unsubscribe = store.subscribe(() =>
  console.log(store.getState())
);

// 发起 action
store.dispatch(addTodo('Learn about redux'))

// 停止监听 state 更新
unsubscribe();
```
从例子里面可以发现，action 和 reduce 都是很常见的函数和对象，在 index.js 文件里面才出现了跟 redux 相关的调用，首先看下 `createStore(todoApp)` 做了什么。

API 文档中说是创建一个 Redux store 来以存放应用中所有的 state，有三个参数依次是：
1. reducer：是一个方法，这个方法接收两个参数，分别是当前的 state 树和要处理的 action，返回新的 state 树。
2. preloadedState：初始 state。
3. enhancer：是一个组合 store creator 的高阶函数，返回一个新的强化过的 store creator。

在 `createStore(todoApp)` 中用到了第一个参数，传参也符合文档描述要求。看了源码后，发现除了文档说的作用，还有其它的作用。

先列出 createStore 方法中主要组成
```javascript
function createStore(reducer, preloadedState, enhancer) {
  // 主要变量
  var currentReducer = reducer
  var currentState = preloadedState
  var currentListeners = []
  var nextListeners = currentListeners
  var isDispatching = false

  // 方法
  function ensureCanMutateNextListeners() {} // 对 currentListeners 浅复制
  function getState() {} // 获取当前 state
  function subscribe(listener) {} // 添加监听
  function dispatch(action) {} // 分发 action ，这是唯一能够让 state 改变的方式。
  function replaceReducer(nextReducer) {} // 替换当前 reducer
  function observable() {} // 可观察/反应库的互操作点

  // 主要执行逻辑
  dispatch({
    type: ActionTypes.INIT
  })

  return {
    dispatch,
    subscribe,
    getState,
    replaceReducer,
    [$$observable]: observable
  }
}
```
其中 ActionTypes.INIT 并不是 createStore 的内部变量，找到后是这样的：
```javascript
/**
 * 这些是 Redux 内部保留的私有 action 类型
 */
const randomString = () =>
  Math.random()
    .toString(36)
    .substring(7)
    .split('')
    .join('.')

const ActionTypes = {
  INIT: `@@redux/INIT${randomString()}`,
  REPLACE: `@@redux/REPLACE${randomString()}`,
  PROBE_UNKNOWN_ACTION: () => `@@redux/PROBE_UNKNOWN_ACTION${randomString()}`
}

export default ActionTypes
```
差不多齐了，可以发现在 createStore 执行后除了对外提供一些常见的接口，主要就执行了一次 dispatch 触发了一次 state 初始化操作，那么接着就是看下 dispatch 方法里面做了什么。除去检查和容错处理，主要的逻辑如下：
```javascript
  function dispatch(action) {
    try {
      isDispatching = true
      currentState = currentReducer(currentState, action)
    } finally {
      isDispatching = false
    }

    const listeners = (currentListeners = nextListeners)
    for (let i = 0; i < listeners.length; i++) {
      const listener = listeners[i]
      listener()
    }

    return action
  }
```
处理的逻辑：
1. 将分发的状态置为 true ，表示正在分发 action。
2. 设置当前 state，其中 `currentReducer` 就是一开始传给 `createStore` 的参数 todoApp，也就是 reducer.js 文件里面导出的方法 todoApp，这时传入的 ActionTypes.INIT 在程序中没有匹配，返回了默认的 initialState。
3. state 产生变化，执行相关监听程序。

初始化的过程就这样结束了。这个函数里面就是 redux 的主要实现逻辑，简单来说就是将我们自己编写的 action 和 reducer，通过 dispatch 方法一一对应起来，每次想要改变 state，必须要通过 dispatch 方法。例如 index.js 文件里面后面执行的语句：
```javascript
store.dispatch(addTodo('Learn about redux'))
```
`addTodo` 是 action 创建函数，返回的结果是 `{ type: 'ADD_TODO', 'Learn about redux' }`，通过 dispatch 方法，将这个结果传递了 reducer.js 里面的 todoApp 方法接收，进行相应的处理后，返回了新的 state 值 `{todos:[{text: 'Learn about redux', completed: false}]}`。

更加详细的代码和注释见源文件 [createStore.js][url-file-create-store]。

<div align="right"><a href="#index">Back to top :arrow_up:</a></div>

## <a name="other"></a> 其它 API 实现
下面针对几个其它 API 的实现介绍一下。

### combineReducers
使用：combineReducers(reducers) <br />
作用：是把一个由多个不同 reducer 函数作为 value 的 object，合并成一个最终的 reducer 函数，然后就可以对这个 reducer 调用 createStore 方法。<br />
参数：reducers 是一个对象，它的值（value）对应不同的 reducer 函数。<br />

列出主要相关代码：
```javascript
// 错误处理和提示
function getUndefinedStateErrorMessage(key, action) {}
// 错误处理和提示
function getUnexpectedStateShapeWarningMessage(inputState,reducers,action,unexpectedKeyCache) {}
// 对 reducer 的检查、判断以及错误提示
function assertReducerShape(reducers) {}

export default function combineReducers(reducers) {
  const reducerKeys = Object.keys(reducers)
  const finalReducers = {}
  for (let i = 0; i < reducerKeys.length; i++) {
    const key = reducerKeys[i]
    if (typeof reducers[key] === 'function') {
      finalReducers[key] = reducers[key]
    }
  }
  const finalReducerKeys = Object.keys(finalReducers)

  let shapeAssertionError
  try {
    assertReducerShape(finalReducers)
  } catch (e) {
    shapeAssertionError = e
  }

  return function combination(state = {}, action) {
    if (shapeAssertionError) {
      throw shapeAssertionError
    }

    let hasChanged = false
    const nextState = {}
    for (let i = 0; i < finalReducerKeys.length; i++) {
      const key = finalReducerKeys[i]
      const reducer = finalReducers[key]
      const previousStateForKey = state[key]
      const nextStateForKey = reducer(previousStateForKey, action)
      nextState[key] = nextStateForKey
      hasChanged = hasChanged || nextStateForKey !== previousStateForKey
    }
    return hasChanged ? nextState : state
  }
}
```

combineReducers 方法主要逻辑是：
1. 获取 reducers 中属性值是方法的属性，并单独提取出属性名形成数组 finalReducerKeys。
2. 对数据 reducers 数据正确性进行检查，例如是否有值等。
3. 返回一个函数，当执行 dispatch 的时候，根据 finalReducerKeys 数组循环所有的 reducer 函数并，得到最新的 state。


<div align="right"><a href="#index">Back to top :arrow_up:</a></div>

## <a name="think"></a> 思考
看完 Redux 的主要逻辑后，一开始觉得有点惊讶，它好的地方除了文档上的描述的优点，还有什么？后来想到里面强调的一个“纯函数”的概念，去了解后才感觉到其中妙的地方。
> 纯函数是这样一种函数，对于相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用。

纯函数带来的好处：
- 可移植性
- 可测试性
- 合理性
- 并行代码

再来看一下在学校里面函数的概念：
> 函数是不同数值之间的特殊关系：每一个输入值返回且只返回一个输出值。。

纯函数就是数学上的函数。这一点让我想到平时编程的时候，好像也写过类似 y=x+1 的程序，但 Redux 在实现的时候不仅运用这种思想，在整体使用方式上，个人觉得也是遵循了这种思想， Action、Reducer 分别相当于函数中的 x、y，Redux 相当于函数的对应关系。回想起之前工作中碰到使用 MVC 中混乱的相互调用，如果使用时想到函数的思想，也是可以达到状态清晰的效果。还有就是对抽取公共方法的思考，为了兼容各种情况，对于相同的输入得到不容的结果是否合理。

把简单的思想巧妙的运用和扩展，这是个人感觉 Redux 最妙的地方。

<div align="right"><a href="#index">Back to top :arrow_up:</a></div>


## <a name="reference"></a> 参考资料
- [Redux Github][url-github-redux]
- [Redux][url-docs-redux]
- [JavaScript 函数式编程][url-blog1]

[url-base]:https://xxholic.github.io/blog/draft

[url-github-redux]:https://github.com/reduxjs/redux
[url-docs-redux]:https://redux.js.org/
[url-blog1]:https://github.com/MostlyAdequate/mostly-adequate-guide/blob/master/ch03.md

[url-file-create-store]:https://github.com/reduxjs/redux/blob/master/src/createStore.js




