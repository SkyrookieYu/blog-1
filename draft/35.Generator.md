# 34.Promise
## <a name="index"></a> 目录
- [引子](#start)
- [异步](#async)
- [回调](#callback)
- [Promise](#promise)
- [Promise 缺点](#promise-weakness)
- [Properties of the Promise Prototype Object](#promise-prototype)
  - [then](#then)
  - [catch](#catch)
  - [finally](#finally)

- [参考资料](#reference)


## <a name="start"></a> 引子
在 [Promise][url-blob-34] 中解决了回调可信任性问题，Promise 自身最大的问题就是代码冗余，过多的 then 语句也让语义变得模糊。接下来看另外一种表达方式更加优雅的异步方案：Generator 函数。

## <a name="async"></a> Generator
Generator 翻译过来是生成器，在形式上，生成器函数是一个普通的函数，先来看一个简单的例子。
```javascript
  var x = 1;
  function *foo() {
    x++;
    yield;
    x++;
    return x;
  }

  var it = foo();
  console.info('it:',it);
  var firstNext = it.next();
  console.log("firstNext:", firstNext);
  console.log('x:',x);
  var secondNext = it.next();
  console.log("secondNext:", secondNext);
  console.log('x:',x);
  var thirdNext = it.next();
  console.log("thirdNext:", thirdNext);
  console.log('x:',x);
```
<details>
<summary>点击查看结果</summary>

![35-generator-demo][url-local-generator-demo]
</details>

foo 函数就是一个生成器函数，这类函数有两个特征：
1. function 关键字与函数名之间有一个星号，星号的位置并没有强行规定，靠近 function 或函数名都可以；
2. 函数体内使用 yield 表达式，定义不同的内部状态。

调用生成器函数跟一般函数一样，不同的是，该函数并不执行，只是构造了一个 iterator（迭代器），迭代器会控制它的执行，下面会介绍。从上面结果可以看出，返回的结果处于 suspended（暂停）状态。

第一个 it.next() 启动了生成器开始运行。next 方法会让生成器函数从函数头部或上一次停下来的地方开始执行，直到遇到下一个 yield 或 return 语句为止。也就是说，yield 语句是暂停执行的标记，翻译过来是产出或让步，next 方法可恢复执行。从上面运行的结果，可以看出在 yield 语句暂停了，x 的值是 2。此外，next 方法会返回一个对象，含有 value 和 done 两个属性，value 是 yield 表达式的值，done 是一个布尔值，表示是否遍历结束。

第二个 it.next()，生成器函数从上次 yield 停下的地方继续执行，一直执行到 return 语句。next 方法返回的对象中，value 的值是 return 语句后面表达式的值，如果没有 return 语句，则 value 属性值为 undefined。done 属性值是 true，表示遍历结束。

第三个 it.next()，此时生成器函数已经运行结束，next 方法返回的对象 value 属性值为 undefined，done 属性值为 true。以后如果再调用 next 方法，返回的结果都是这样。

从上面的例子中，可以发现生成器就是类特殊的函数，可以一次或多次启动和停止，并不一定非要完成。

## Iterator
迭代器（Iterator）是一个定义良好的接口，用于从一个生产者一步步得到一系列值。

JavaScript 中 Iterator 的作用有：
1. 为各种不同的数据结构提供统一的访问接口。
2. 使得数据结构的成员能够按某种次序排列。
3. Iterator 接口主要供 for...of 遍历命令使用。

使用 next 方法获取生产者一系列的值。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作。默认的 Iterator 接口部署在数据结构的 Symbol.iterator 属性。
```javascript
const produceNumber = (function() {
  var nextNum;
  return {
    [Symbol.iterator]: function() { return this; },
    next: function() {
      if (nextNum === undefined) {
        nextNum = 1;
      } else {
        nextNum = nextNum + 2;
      }

      return {done: nextNum>=9, value: nextNum}
    }
  }
})();

console.info(produceNumber.next().value); // 1
console.info(produceNumber.next().value); // 3

for (const iterator of produceNumber) {
  console.info(iterator);
}
// 5
// 7
```
其中 [Symbol.iterator] 语法，这是 ES6 新增的**可计算属性名**，可以在文字形式中使用 [] 包裹一个表达式来当做属性名：
```javascript
var prefix = 'book';

var myObj = {
  [prefix + 'red']:'how to laugh',
  [prefix + 'blue']:'how to cry',
}

myObj["bookread"] // how to laugh
```
可计算属性名最常用的场景可能是 ES6 的 Symbol。属性名 Symbol.iterator，它是一个表达式，返回 Symbol 对象的 iterator 属性，这是一个预定义好的、类型为 Symbol 的特殊值。

原生具有 Iterator 接口的数据结构有：
- Array
- Map
- Set
- String
- TypedArray
- 函数的 arguments 对象
- NodeList 对象

举个例子：
```javascript
const str = 'string';
const iter = str[Symbol.iterator]();
console.info(iter.next()); // {value: "s", done: false}
console.info(iter.next()); // {value: "t", done: false}
```

## <a name="yield"></a> yield




## <a name="reference"></a> 参考资料
- [MDN Promise][url-mdn-promise]
- [Promises/A+][url-promisesaplus]
- [promises-unwrapping][url-promises-unwrapping]
- [ECMAScript 6 入门][url-ruanyifeng-promises]
- [You-Dont-Know-JS][url-github-book]
- [Async JavaScript: From Callbacks, to Promises, to Async/Await][url-tylermcginnis-promises]

[url-base]:https://xxholic.github.io/blog/draft

[url-mdn-promise]:https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise
[url-promisesaplus]:https://promisesaplus.com/
[url-promises-unwrapping]:https://github.com/domenic/promises-unwrapping
[url-ruanyifeng-promises]:http://es6.ruanyifeng.com/#docs/promise
[url-github-book]:https://github.com/getify/You-Dont-Know-JS
[url-tylermcginnis-promises]:https://tylermcginnis.com/async-javascript-from-callbacks-to-promises-to-async-await/

[url-local-generator-demo]:./images/35/generator-demo.png


[url-blog-34]:https://github.com/XXHolic/blog/issues/34