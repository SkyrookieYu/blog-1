# 77.Scalable Frontend 3 —The State Layer.80
## <a name="index"></a> 目录
- [引子](#start)
- [main](#正文)
  - [title11](#title11)
- [参考资料](#reference)


## <a name="start"></a> 引子
继 [Scalable Frontend 2 — Common Patterns][url-2] 第三篇，继续翻译记录。

原文：[Scalable Frontend #3 — The State Layer][url-1]

## <a name="main"></a> 正文
![77-head][url-local-1]
*状态树，实际山个就是单一来源*

在处理用户界面时，无论我们使用的应用程序的规模有多大，必须要管理显示给用户或由用户更改的状态。来源可能是从 API 获取的列表、从用户的输入获得、来自本地存储的数据等等。不管这些数据来自何处，我们都必须对其进行处理，并使用持久化方法使其保持同步，无论是远程服务器还是浏览器存储。

准确地说，这就是我们所说的 *本地状态* （local state），我们应用程序使用和依赖的特定的一部分数据。有很多原因可以解释为什么、何时、何地更新和使用状态，如果我们不恰当地管理它，它可能很快失控。即使是一张简单的报名表，也可能需要处理很多状态：
- 当用户与字段交互时，检查是否填写了有效数据；
- 跳过未触及字段的验证，直到表单提交；
- 当下拉选择一个国家时，触发获取该国家下州的请求，然后缓存响应；
- 根据所选国家，更改语言下拉可选项。

噢！听起来很棘手，对吧？

在本文中，我们将讨论如何以合理的方式管理本地状态，始终牢记代码库的可伸缩性和架构设计原则，以避免状态层和其他层之间的耦合。应用程序的其余部分不应该知道状态层或正在使用的库，如果有的话。我们只需要告诉视图层如何从状态中获取数据，以及如何分发操作，它们将调用组成我们应用程序行为的用例。

在过去的几年中，JavaScript 社区中出现了许多用于管理本地状态的库，这些库以前主要由双向数据绑定竞争者控制，例如 Backbone、Ember 和 Angular 。直到随着 [Flux][url-3] 和 React 的出现，单向数据流才变得流行起来，人们意识到 MVC 对于前端应用程序并不很适用。随着在前端开发中大量采用函数式编程技术，我们可以理解为什么像 Redux 这样的库如此流行并影响了整整一代的状态管理库。

> 如果你想要更多了解这个主题，这里有个很好的关于 [Flux 思维模式的演示][url-4]。

现在，有好几个流行的状态管理库，其中一些特定于某些生态系统，比如 NgRx 是用于 Angular 。为了熟悉起见，我们将使用 Redux ，但是本文中提到的所有概念适用于所有的库，甚至没有库的情况。记住这一点，你应该使用最适合你和你的团队的方案。不要因为一个库到处有宣传，使用它就感到有压力。如果对你适用，那就去用吧。


## <a name="citizens"></a> 公民：actions、action 创建者、reducers 和 store
在现代前端应用程序的状态管理中，我们会发现这四个是最常见的对象类型。用 actions 将事件从副作用的影响中分离出来的想法并不新鲜。事实上，这些公民都是基于成熟的想法，例如 [event sourcing][url-5]、[CQRS][url-6] 和 [mediator][url-7] 设计模式。

它们共同运作的方式是，通过集中存储和更改状态的方式，限制在一个地方并分发 actions（又称事件）来触发状态更改。一旦更改应用于状态，我们会通知对其感兴趣的部分，它们会更新自己以反映新的状态。这是单向数据流循环。

![77-one-way][url-local-2]
*循环*

### <a name="actions"></a> Actions and action 创建者
Actions 通常被实现为具有两个属性的对象：`type` 属性和传递给 store 执行对应操作的数据 `data` 。例如，触发创建用户的 action 可能是以下格式：
```js
{
  type: 'CREATE_USER',
  userData: { name: 'Aragorn', birthday: '03/01/2931' }
}
```
需要注意的是，`type` 属性的实现因所使用的状态管理库而异，但大多数情况下它都是一个字符串。另外，请记住，示例中的 action 本身并不创建用户；它只是一条消息，告诉 store 使用 `userData` 创建用户。

> **Action 创建者是把创建 action 对象抽象为一个可复用单元的函数**

但是，如果我们需要从代码中的多个位置触发相同的 action ，比如测试套件或另一个文件，该怎么办？我们如何使其可重用，并对分发它的单元隐藏 action 类型？我们使用 action 创建者！Action 创建者是把创建 action 对象抽象为一个可复用单元的函数。我们前面的示例可以由下面的 action 创建者封装：
```js
const createUser = (userData) => ({
  type: 'CREATE_USER',
  userData
});
```
现在，每当我们需要分发 `CREATE_USER` 的 action 时，我们导入这个函数并使用它来创建将分发到我们 store 的 action 对象。

### <a name="store"></a> Store
store 是我们真实状态的唯一来源，是我们存储和修改状态的唯一的地方。每次更改状态时，我们都会向 store 分发一个 action ，描述想要执行的更改，并在需要时提供额外的信息（分别对应示例中的 type 和 userData）。这意味着我们永远不应该在同一位置使用和更改状态，而是让 store 来更新状态。在这种模式的大多数实现中，我们都会 *订阅* ，当 store 执行变更时会得到相应通知，以便对更改做出反应。

> **store 是我们真实状态的唯一来源。**

好了，现在我们知道 store 可以用于两个主要目的：分发 actions 和向订阅者触发事件。在 React 应用程序中，通常用 [Redux][url-8] 创建 store ，使用 [react-redux’ connect][url-9] 分发 actions（`mapDispatchToProps`）和监听变更（`mapStateToProps`）。但我们也可以用一个根组件，使用 [Context API][url-10] 来存储状态，相应的使用 [Context.Consumer][url-11] 来分发 actions 和监听变更。或者我们可以用一个更简单的方式：[状态提升][url-12]。对于 Vue ，有一个跟 Redux 很类似的库 [Vuex][url-13] ，我们使用 [dispatch][url-14] 触发 actions ，用 [mapState][url-15] 来监听 store 。同样的，我们可以用 [@ngrx/store][url-16] 在 Angular 应用程序中做同样的事情。

尽管存在差异，但所有这些库都有一个共同的理念：单向循环。每次需要更新状态时，我们都会将 actions 发送到 store ，然后进行执行并通知监听者。千万不要回头或跳过这些步骤。

### <a name="reducers"></a> Reducers
但 store 如何更新状态并处理每个 action 类型？这就是 reducers 派上用场的地方。老实说，它们并不总是被称为“reducers”，例如，在 Vuex 中，它们被称为“mutations”。但中心思想是一样的：一个获取应用程序当前状态和正在处理的 action ，返回一个全新的状态，或者使用设置器对当前状态进行修改的函数。store 将更新委托给此函数，然后将新状态通知给监听者。这就结束了循环！

> **每个 reducer 都应该能够处理我们应用中的任何 action 。**

在结束这部分之前，有一条**非常重要**的规则需要强调：每个 reducer 都应该能够处理我们应用中的任何 action 。换句话说，一个 action 可以同时由多个 reducer 处理。因此，这条规则允许单个 action 在状态的不同部分触发多个更改。这里有个很好的例子：在一个 AJAX 请求完成后，我们可以在 reducer X 中的根据响应更新本地状态，在 reducer Y 中隐藏加载器，甚至在 reducer Z 中显示一条成功的消息，其中每个 reducer 都有更新状态不同部分的单一责任。

## <a name="designing"></a>  状态设计
当我们开始编写应用程序时，总会想到一些问题：
- 状态应该是什么样的？
- 应该放什么进去？
- 应该有什么样的形态？

这些问题恐怕没有正确的答案。我们唯一有把握的是一些特定于库的规则，这些规则规定了如何更新状态。例如，在 Redux 中，reducer 函数应该是单一确定性的，并且具有 `（state，action）=>state` 签名。

也就是说，我们可以遵循一些实践来摆脱复杂性并提高 UI 性能，其中的一些是通用的，适用于我们选择的任何状态管理技术。其它的一些则适用于像 Redux 这样的特定的工具，与具有很强函数特性的辅助函数结合，用来分解 reducer 逻辑。

在深入研究之前，我建议你先查看你用来管理状态的库的文档。在大多数情况下，您会发现你不知道的高级技术和辅助方法，甚至本篇文章中没有介绍，但更适用你正在使用的状态管理方案的概念。除此之外，你可以查看第三方库，或者自己构建函数来实现这一点。

### <a name="shape"></a> 状态形态
状态指的是我们需要管理的数据，形态指的是我们如何构造和组织这些数据。形态与数据源无关，但与我们如何构造 reducer 逻辑密切有关。

通常，这个形态是用一个普通的 JavaScript 对象表示，它形成了初始状态树，但也可以使用任何其它值，比如纯数字、数组或字符串。对象的优点是允许将状态组织和划分为有意义的片段，其中根对象的每个键都一个子树，可以表示公共或部分数据。在包含文章和作者的基本博客应用程序中，状态的形态可能如下所示：
```js
{
  articles: [
    {
      id: 1,
      title: 'Managing all state in one reducer',
      author: {
        id: 1,
        name: 'Iago Dahlem Lorensini',
        email: 'iagodahlemlorensini@gmail.com'
      },
    },
    {
      id: 2,
      title: 'Using combineReducers to manage reducer logic',
      author: {
        id: 2,
        name: 'Talysson de Oliveira Cassiano',
        email: 'talyssonoc@gmail.com'
      },
    },
    {
      id: 3,
      title: 'Normalizing the state shape',
      author: {
        id: 1,
        name: 'Iago Dahlem Lorensini',
        email: 'iagodahlemlorensini@gmail.com'
      },
    },
  ],
}
```
请注意，`articles` 是状态的顶级键，它形成了一个代表相同概念数据的子树。我们在每篇文章中也都有一个嵌套的子树来表示作者。一般来说，我们应该避免嵌套数据，因为它增加了 reducer 的复杂性。

Redux 的这篇文档介绍了如何根据你的定义域层和应用程序状态，将数据类型构造到状态形态上。即使你没有使用 Redux ，也去看看！数据管理对于任何类型的应用程序来说都是司空见惯的，对于学习如何对数据进行分类并组织形成你的状态形态，那是一篇非常好的文章。

### <a name="combine"></a> Reducers 合并
上一个示例的状态形态中只显示了一个键，但实际应用程序通常有多个定义域要表示，这意味着一个 reducer 函数中将有更多的更新逻辑。然而，这违背了一个重要的规则：reducer 函数应该精简且聚焦（单一责任原则），以便易于阅读、理解和维护。

在Redux中，我们可以通过内置的 `combineReducers` 函数实现这一点。这个函数接受一个对象，其中每个键表示状态的一个子树，并返回一个带有描述名称的组合 reducer 函数。让我们将 `authors` 和 `articles` 的 reducer 合并到一个 `rootReducer` 中：
```js
import { combineReducers } from 'redux'

const authorsReducer = (state, action) => newState

const articlesReducer = (state, action) => newState

const rootReducer = combineReducers({
  authors: authorsReducer,
  articles: articlesReducer,
})
```
传递给 `combineReducer` 的键将用于形成状态的最终形态，其数据将由与各自键相关联的 reducer 函数进行转换。因此，如果我们传递 `authors` 键和 `authorsReducer`  函数，`rootReducer` 返回的将是由 `authorsReducer` 函数管理的 `state.authors` 。

当我们更深入的拆分 reducer 函数时，合并 reducers 也很棒。假设 `articlesReducer` 需要处理这种情况：跟踪在获取文章的过程中发生的错误。所以现在我们状态中 `articles` 的键将不再是一个数组，而是一个如下的对象：
```js
{
  isLoading: false,
  error: null,
  list: [] // <- this is the array of articles itself
}
```
我们可以在 `articlesReducer` 内部处理这种新情况，但在同一个地方我们会有更多的声明要处理。幸运的是，这可以通过将 `articlesReducer` 分解成更小的部分来解决：
```js
const isLoadingReducer = (state, action) => newState

const errorReducer = (state, action) => newState

const listReducer = (state, action) => newState

const articlesReducer = combineReducers({
  isLoading: isLoadingReducer,
  error: errorReducer,
  list: listReducer,
})
```
除了 `combinerReducers` ，还有其它方法可以分解 reducer 逻辑，但我们将说明转交给 [Redux 文档][url-17]，文档对可复用技术例如高阶 reducer 、切片 reducer ，和减少样板代码的方法进行了很好的描述。请注意，这些方法也适用于 [VueX 模块][url-18]（本文将再次提及）和 [NgRx][url-19] 。


### <a name="combine"></a> Normalization

## Common Patterns

## Selectors

## Ducks/Modules

## State Machines

## Common Pitfalls














<div align="right"><a href="#index">Back to top :arrow_up:</a></div>

## <a name="reference"></a> 参考资料
- [article][url-article-1]

[url-1]:https://blog.codeminer42.com/scalable-frontend-3-the-state-layer-b23ed69ca57c/
[url-2]:https://github.com/XXHolic/blog/issues/79
[url-3]:https://github.com/facebook/flux
[url-4]:https://www.youtube.com/watch?list=PLb0IAmt7-GS188xDYE-u1ShQmFFGbrk0v&v=nYkdrAPrdcw
[url-5]:https://martinfowler.com/eaaDev/EventSourcing.html
[url-6]:https://martinfowler.com/bliki/CQRS.html
[url-7]:https://sourcemaking.com/design_patterns/mediator
[url-8]:https://redux.js.org
[url-9]:https://react-redux.js.org/api/connect
[url-10]:https://reactjs.org/docs/context.html
[url-11]:https://reactjs.org/docs/context.html#contextconsumer
[url-12]:https://reactjs.org/docs/lifting-state-up.html
[url-13]:https://vuex.vuejs.org/guide/state.html
[url-14]:https://vuex.vuejs.org/guide/actions.html
[url-15]:https://vuex.vuejs.org/guide/state.html#the-mapstate-helper
[url-16]:https://ngrx.io/guide/store
[url-17]:https://redux.js.org/recipes/structuring-reducers/splitting-reducer-logic
[url-18]:https://vuex.vuejs.org/guide/modules.html
[url-19]:https://ngrx.io/api/store/combineReducers

[url-local-1]:./images/77/head.jpeg
[url-local-2]:./images/77/one-way.png

<details>
<summary>:wastebasket:</summary>

![n-poster][url-local-poster]

</details>

[url-book]:https://book.douban.com/subject/26916012/
[url-local-poster]:./images/n/poster.jpg
