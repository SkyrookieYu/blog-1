# 53.前端异常类型及捕获.53
## <a name="index"></a> 目录
- [引子](#start)
- [index 1](#index1)
  - [index 12](#index12)
- [参考资料](#reference)


## <a name="start"></a> 引子
最近对着方面有了兴致，就去花时间查找相关资料。

## 异常类型
从使用浏览器，浏览一个网页，与网页进行交互的过程，从用户的角度想一想会出现那些异常。

首先是使用浏览器一般都是基于一个操作系统，系统自身可能会出现问题，比如内存不够。这类情况归为**系统异常**。

正常打开浏览器后，访问网页的时候，可能没有网络，访问的网页提示出现服务错误，等待过程中突然断网了，将这类情况归为**网络异常**。

能够正常访问网页后，用户进行交互操作时，可能出现一种情况下点击有效，一种条件下点击无效，这类情况归为**应用异常**。

在上面比较感性的认识基础上，进一步的进行细化。

### 系统异常
系统异常情况比较少：
- 浏览器崩溃

### 网络异常
网络异常中，前端相关的有：
- XMLHttpRequest 请求异常
- Fetch 请求异常
- 静态资源加载异常
- iframe 异常
- 跨域

### 应用异常
应用异常可以用 JavaScript 中的错误对象体现出来：
- EvalError ： 与 eval() 有关的错误。
- RangeError ： 表示这个值不在允许值集或范围内。
- ReferenceError ： 表示发现一个无效的引用。
- SyntaxError ： 表示发生了解析错误。
- TypeError ：当其它类型错误都符合时，TypeError 用于指示一个不成功的操作。
- URIError ：表示用于处理 URI 的函数（encodeURI 或 decodeURl）使用方式与其定义的不兼容。

比较常见的异常可以参考 [Top 10 JavaScript errors from 1000+ projects][url-article-1] 。


## 异常捕捉
浏览器都具有某种向用户报告异常的机制，对于用户都是隐藏此类信息。对于开发者，一般在控制台可以看到相关信息。下面看下能够捕获异常的方法。
### try-catch
try-catch 使用的形式如下：
```js
try {
  // 可能导致异常的代码
} catch(error) {
  // 发生异常时的处理
}
```
测试页面见[这里][url-lab-1]，有下面的一些特点：
- `catch` 块中会接收一个包含异常信息的对象，在不同的浏览器中包含了信息可能不同，但共同有一个保存异常信息的 `message` 属性。
- 不能捕获语法异常。
- 不能捕获异步异常。
- 该方式捕获的异常，不会出现在控制台上，也不会被 `error` 事件捕获。

语法异常在开发的阶段就很容易发现，例如：
```js
try {
  var num = '333;
} catch(error) {
  console.info('try-catch：', error);
}
```
不能捕捉异步异常示例如下：
```js
try {
  setTimeout(() => {
    name.forEach(() => {});
  },1000)
} catch(error) {
  console.info('try-catch：', error);
}
```

try-catch 比较合适处理那些可以预见可能出错的地方。
### error 事件
通常将这个事件绑定在 window 上，但由于历史原因，使用 DOM 不同级别的绑定方式，会有些差别。测试页面见[这里][url-lab-1]

#### DOM0 级方式
也就是使用 `window.onerror` 指定处理程序，其特点有：
- 参数有 5 个，对应含义分别为 message-错误信息（字符串）、source-发生异常的脚本URL（字符串）、lineno-发生异常的行号（数字）、colno-发生异常的列号（数字）、error-Error 对象（对象）。
- 函数体内用 `return true` 可以阻止异常信息出现在控制台。
- 可以捕获异步异常。
- 不能捕获到语法异常。
- 不能捕获 `try-catch` 中的异常。
- 不能捕获 script、img、input、audio、source、track 标签元素 src 属性的加载异常（HTML5 不支持的 frame 标签不讨论）。测试页面见[这里][url-lab-2]。

#### DOM2 级方式
也就是使用 `window.addEventListener` 指定处理程序，其特点有：
- 参数对应 1 个，是一个 `ErrorEvent` 对象，其中包含信息相对 DOM0 级更加丰富。
- 函数体内用 `preventDefault()` 方法可以阻止异常信息出现在控制台，但如果是加载资源异常无法阻止。
- 可以捕获 script、img、input、audio、source 标签元素 src 属性的加载异常（track 尝试了一下不行）。由于加载请求不会冒泡，所有需要在事件的捕获阶段监听才行。但这种方式无法知道 HTTP 的相关状态。测试页面见[这里][url-lab-2]。
- 可以捕获异步异常。
- 不能捕获到语法异常。
- 不能捕获到 `try-catch` 中的异常。


onerror 事件比较适合捕获预料之外的异常。

### Promise Catch、Async/Await
没有写 catch 的 Promise 中抛出的错误无法被 onerror 或 try-catch 捕获到，所以我们务必要在 Promise 中不要忘记写 catch 处理抛出的异常。

为了防止有漏掉的 Promise 异常，建议在全局增加一个对 unhandledrejection 的监听，用来全局监听Uncaught Promise Error





<div align="right"><a href="#index">Back to top :arrow_up:</a></div>

## <a name="reference"></a> 参考资料
- [MDN Error][url-mdn-1]
- [如何优雅处理前端异常？][url-article-3]
- [Top 10 JavaScript errors from 1000+ projects][url-article-1]
- [前端异常监控解决方案研究][url-article-2]
- http://thecodebarbarian.com/async-await-error-handling-in-javascript.html
- https://blog.fundebug.com/2019/07/24/async-await-error-handling-in-js/
- https://blog.fundebug.com/2018/03/12/top-10-javascript-errors-from-1000-projects/

[url-article-1]:https://rollbar.com/blog/top-10-javascript-errors/
[url-article-2]:https://cdc.tencent.com/2018/09/13/frontend-exception-monitor-research/
[url-article-3]:http://jartto.wang/2018/11/20/js-exception-handling/index.html

[url-mdn-1]:https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Error

[url-stackoverflow-1]:https://stackoverflow.com/questions/15273042/catch-error-if-iframe-src-fails-to-load-error-refused-to-display-http-ww

[url-lab-1]:https://xxholic.github.io/lab/blog/53/index.html
[url-lab-2]:https://xxholic.github.io/lab/blog/53/src.html
[url-lab-3]:https://xxholic.github.io/lab/blog/53/iframe.html